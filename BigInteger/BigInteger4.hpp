/*! \file   BigInteger4.hpp
 *  \brief  A "fourth generation" definition of an extended precision integer class.
 *  \author Peter Chapin <peter.chapin@vermontstate.edu>
 * 
 * In this version a vector<storage_type> is used to hold the digits. Since vectors have their
 * own lifecycle operations which are invoked by the lifecycle operations generated by the
 * compiler for this class, there is a massive amount of simplification here.
 */


#ifndef BIGINTEGER_HPP
#define BIGINTEGER_HPP

#include <iosfwd>
#include <memory>
#include <string>
#include <vector>

namespace vtsu {

    class BigInteger {

        friend std::ostream &operator<<( std::ostream &os, const BigInteger &bi );
        
    public:
        //! Exception thrown when an invalid format is used to construct a BigInteger.
        class InvalidFormat : std::runtime_error {
        public:
            InvalidFormat( const std::string &message ) : std::runtime_error( message ) { }
        };

        //! Exception thrown when an operation is not implemented.
        class NotImplemented : std::logic_error {
        public:
            NotImplemented( const std::string &message ) : std::logic_error( message ) { }
        };

        // The default constructor is not generated because other constructors exist. However,
        // it doesn't need to do anything since the compiler will ensure the members are default
        // constructed.
        BigInteger( ) = default;

        // None of these are needed. The compiler generated versions are fine!
        //BigInteger( const BigInteger &other );            // Copy constructor.
        //BigInteger &operator=( const BigInteger &other ); // Copy assignment operator.
        //BigInteger( BigInteger &&other );                 // Move constructor.
        //BigInteger &operator=( BigInteger &&other );      // Move assignment operator.

        BigInteger( unsigned long value );

        /*!
         * \param raw_digits The string of decimal digits. The digits are assumed to be in
         *  big-endian order. That is, the most significant digit is first and the least
         *  significant digit is last. No characters other than digits are allowed.
         * 
         * \throws InvalidFormat if the string contains any non-digit characters.
         * \throws std::overflow_error if the string contains a value that is too large to be
         * represented by a BigInteger.
         */
        BigInteger( const std::string &raw_digits );

        // Operator methods for supporting the usual arithmetic operations.
        //
        // These methods take 'right' by reference to avoid copying large objects. It is a
        // reference to const since the operations do not attempt to modify their right
        // operands. These methods return a reference to 'this' so that they can be chained.
        BigInteger &operator+=( const BigInteger &right );
        BigInteger &operator*=( const BigInteger &right );

        //! Conversion operator to convert BigInteger to unsigned long.
        /*!
         * \throws std::overflow_error if the BigInteger is too large to fit in an unsigned long.
         */
        operator unsigned long( );

    private:
        using storage_type = std::uint32_t;
        using compute_type = std::uint64_t;

        // INVARIANT: If the represented value is zero, the digits vector is empty. Otherwise
        // the first digit in the vector is the least signification digit. Leading zero digits
        // are never stored.
        std::vector<storage_type> digits;
    };
    

    inline BigInteger operator+( const BigInteger &left, const BigInteger &right )
    {
        BigInteger temp( left );
        temp += right;
        return temp;
    }

}


#endif
